package info.bitcoinunlimited.www.wally
import info.bitcoinunlimited.www.wally.ui.ScreenId
import kotlinx.coroutines.channels.Channel
import org.nexa.libnexakotlin.GetLog
import org.nexa.libnexakotlin.launch
import org.nexa.libnexakotlin.millinow

private val LogIt = GetLog("wally.alert")
// Alerts are something that you want to show to the user

enum class AlertLevel(val level: Int)
{
    CLEAR(-1),  // Not an alert level -- removes other alerts
    SUCCESS(1), // Green
    NOTICE(10),  // Just informative -- neutral color
    WARN(50),    // yellow
    ERROR(100),  // red
    EXCEPTION(200); // red

    fun longevity(): Long
    {
        return when
        {
            level >= EXCEPTION.level -> ERROR_DISPLAY_TIME
            level >= ERROR.level -> ERROR_DISPLAY_TIME
            level >= WARN.level -> NOTICE_DISPLAY_TIME
            level >= NOTICE.level -> NORMAL_NOTICE_DISPLAY_TIME
            level == CLEAR.level -> 0
            else -> NORMAL_NOTICE_DISPLAY_TIME
        }
    }
}

data class Alert(val msg: String, val details: String?, val level: AlertLevel, val trace:String? = stackTraceWithout(mutableSetOf("displayError\$default","displayError","displayNotice")), var persistAcrossScreens:Int = 1, val longevity:Long? = null, val date: Long = millinow())

/** Communicate incoming alerts to the GUI */
val alertChannel = Channel<Alert>()

/** all the alerts/notices generated by this app so far */
val alerts = arrayListOf<Alert>()

val defaultIgnoreFiles = mutableListOf<String>("ZygoteInit.java", "RuntimeInit.java", "ActivityThread.java", "Looper.java", "Handler.java", "DispatchedTask.kt")

fun clearAlert(msg: String)
{
    val alert = Alert(msg, null, AlertLevel.CLEAR, null, 1, 0)
    launch { alertChannel.send(alert) }
}

/** Clears all alerts, even those marked to persist across screens.
 * This is typically done in response to a user action since any explicit action implies that the user has seen the alert
 */
fun clearAlerts(maxLevel: AlertLevel = AlertLevel.EXCEPTION)
{
    val alert = Alert("", null, maxLevel, null, 1, 0)
    if (platform().hasNativeTitleBar) displayAlert(alert)
    else
    {
        launch { alertChannel.send(alert) }
    }
}
/** Clears nonpersistent alerts.  Typically done as part of an automatic action */
fun clearScreenAlerts(maxLevel: AlertLevel = AlertLevel.EXCEPTION)
{
    val alert = Alert("", null, maxLevel, null, 0, 0)
    if (platform().hasNativeTitleBar) displayAlert(alert)
    else
    {
        launch { alertChannel.send(alert) }
    }
}

/** Display a notice message, and add it to the list of alerts */
fun displaySuccess(summary: Int, message: String?=null, persistAcrossScreens: Int = 1) = displayNotice(i18n(summary), message, persistAcrossScreens)

fun displaySuccess(summary: String, message: String?=null, persistAcrossScreens: Int = 1)
{
    val alert = Alert(summary, message, AlertLevel.SUCCESS, null, persistAcrossScreens, NORMAL_NOTICE_DISPLAY_TIME)

    if (platform().hasNativeTitleBar)
        displayAlert(alert)
    else
    {
        alerts.add(alert)
        launch { alertChannel.send(alert) }
    }
}

/** Display a notice message, and add it to the list of alerts */
fun displayNotice(summary: Int, message: String?=null, persistAcrossScreens: Int = 1) = displayNotice(i18n(summary), message, persistAcrossScreens)

fun displayNotice(summary: String, message: String?=null, persistAcrossScreens: Int = 1)
{
    val alert = Alert(summary, message, AlertLevel.NOTICE, null, persistAcrossScreens, NOTICE_DISPLAY_TIME)

    if (platform().hasNativeTitleBar)
        displayAlert(alert)
    else
    {
        alerts.add(alert)
        launch { alertChannel.send(alert) }
    }
}

/** Display an error message, and add it to the list of alerts.
 * you MUST i18n every summary message!  Only use this string based API if you have to parameterize your summary.
 * */
fun displayWarning(summary: String, message: String?=null, persistAcrossScreens: Int = 1)
{
    val alert = Alert(summary, message, AlertLevel.WARN, null, persistAcrossScreens, NORMAL_NOTICE_DISPLAY_TIME)

    if (platform().hasNativeTitleBar)
        displayAlert(alert)
    else
    {
        alerts.add(alert)
        launch { alertChannel.send(alert) }
    }
}


/** Display an error message, and add it to the list of alerts */
fun displayError(summary: Int, message: String?=null, persistAcrossScreens: Int = 1)
{
    val e = Exception()
    LogIt.error("displayError")
    LogIt.error(e.stackTraceToString())
    val alert = Alert(i18n(summary), message, AlertLevel.ERROR, null, persistAcrossScreens, ERROR_DISPLAY_TIME)

    if (platform().hasNativeTitleBar)
        displayAlert(alert)
    else
    {
        alerts.add(alert)
        launch { alertChannel.send(alert)  }
    }
}

/** Display an error message, and add it to the list of alerts */
fun displayError(summary: Int, message: Int, persistAcrossScreens: Int = 1) = displayError(i18n(summary), i18n(message), persistAcrossScreens)



/** Display an error message, and add it to the list of alerts.
 * you MUST i18n every summary message!  Only use this string based API if you have to parameterize your summary.
 * */
fun displayError(summary: String, message: String?=null, persistAcrossScreens: Int = 1)
{
    val e = Exception()
    LogIt.error("displayError")
    LogIt.error(e.stackTraceToString())
    val alert = Alert(summary, message, AlertLevel.ERROR, null, persistAcrossScreens, ERROR_DISPLAY_TIME)

    if (platform().hasNativeTitleBar)
        displayAlert(alert)
    else
    {
        alerts.add(alert)
        launch { alertChannel.send(alert) }
    }
}



/** LAST RESORT: display an exception (and put it into the alert log, so the user can submit an issue report).
 * This should not ever be called in "normal" operation. */
fun displayUnexpectedException(e: Exception)
{
    val summary = e.message ?: e.toString()
    // Android/JVM only: val summary = try { e.localizedMessage } catch (e: Exception) { e.message ?: e.toString()}
    val message = i18n(S.IssueReportInstructions)
    val alert = Alert(summary, message, AlertLevel.EXCEPTION, e.stackTraceToString(), 0, ERROR_DISPLAY_TIME)

    if (platform().hasNativeTitleBar)
        displayAlert(alert)
    else
    {
        alerts.add(alert)
        launch { alertChannel.send(alert) }
    }

    LogIt.severe("Unexpected Exception: ${e} (${e.message})")
    LogIt.severe(e.stackTraceToString())
}

/** LAST RESORT: display an exception (and put it into the alert log, so the user can submit an issue report).
 * This should not ever be called in "normal" operation. */
fun displayUnexpectedError(e: Error)
{
    val summary = e.message ?: e.toString()
    // Android/JVM only: val summary = try { e.localizedMessage } catch (e: Exception) { e.message ?: e.toString()}
    val message = i18n(S.IssueReportInstructions)
    val alert = Alert(summary, message, AlertLevel.EXCEPTION, e.stackTraceToString(), 0, ERROR_DISPLAY_TIME)

    if (platform().hasNativeTitleBar)
        displayAlert(alert)
    else
    {
        alerts.add(alert)
        launch { alertChannel.send(alert) }
    }
}
