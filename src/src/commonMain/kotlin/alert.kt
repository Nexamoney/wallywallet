package info.bitcoinunlimited.www.wally
import kotlinx.coroutines.*
import kotlinx.coroutines.channels.Channel
import org.nexa.libnexakotlin.exceptionHandler
import org.nexa.libnexakotlin.millinow

// Alerts are something that you want to show to the user

enum class AlertLevel(val level: Int)
{
    NOTICE(10),  // Green
    WARN(50),    // yellow
    ERROR(100),  // red
    EXCEPTION(200); // red
}

data class Alert(val msg: String, val details: String?, val level: AlertLevel, val trace:Array<StackTraceElement>? = stackTraceWithout(mutableSetOf("displayError\$default","displayError","displayNotice")), val persistAcrossScreens:Boolean = true, val longevity:Long? = null, val date: Long = millinow())

/** Communicate incoming alerts to the GUI */
val alertChannel = Channel<Alert>()

/** all the alerts/notices generated by this app so far */
val alerts = arrayListOf<Alert>()

val defaultIgnoreFiles = mutableListOf<String>("ZygoteInit.java", "RuntimeInit.java", "ActivityThread.java", "Looper.java", "Handler.java", "DispatchedTask.kt")
fun stackTraceWithout(skipFirst: MutableSet<String>, ignoreFiles: MutableSet<String>?=null): Array<StackTraceElement>
{
    skipFirst.add("stackTraceWithout")
    skipFirst.add("stackTraceWithout\$default")
    val igf = ignoreFiles ?: defaultIgnoreFiles
    val st = Exception().stackTrace.toMutableList()
    while (st.isNotEmpty() && skipFirst.contains(st.first().methodName)) st.removeAt(0)
    st.removeAll { igf.contains(it.fileName) }
    return st.toTypedArray()
}

/** Display a notice message, and add it to the list of alerts */
fun displayNotice(summary: Int, message: String?=null, persistAcrossScreens: Boolean=true)
{
    val alert = Alert(i18n(summary), message, AlertLevel.NOTICE, null, persistAcrossScreens, NOTICE_DISPLAY_TIME)
    alerts.add(alert)
    alertChannel.trySend(alert)  // If nobody is listening, no need to show it
}

/** Display an error message, and add it to the list of alerts */
fun displayError(summary: Int, message: String?=null, persistAcrossScreens: Boolean=true)
{
    val alert = Alert(i18n(summary), message, AlertLevel.ERROR, null, persistAcrossScreens, ERROR_DISPLAY_TIME)
    alerts.add(alert)
    alertChannel.trySend(alert)  // If nobody is listening, no need to show it
}

/** Display an error message, and add it to the list of alerts */
fun displayError(summary: Int, message: Int, persistAcrossScreens: Boolean=true)
{
    val alert = Alert(i18n(summary), i18n(message), AlertLevel.ERROR, null, persistAcrossScreens, ERROR_DISPLAY_TIME)
    alerts.add(alert)
    alertChannel.trySend(alert)  // If nobody is listening, no need to show it
}


/** Display an error message, and add it to the list of alerts.
 * you MUST i18n every summary message!  Only use this string based API if you have to parameterize your summary.
 * */
fun displayError(summary: String, message: String?=null, persistAcrossScreens: Boolean=true)
{
    val alert = Alert(summary, message, AlertLevel.ERROR, null, persistAcrossScreens, ERROR_DISPLAY_TIME)
    alerts.add(alert)
    alertChannel.trySend(alert)  // If nobody is listening, no need to show it
}

/** LAST RESORT: display an exception (and put it into the alert log, so the user can submit an issue report) */
fun displayException(e: Exception)
{
    val summary = try { e.localizedMessage } catch (e: Exception) { e.message ?: e.toString()}
    val message = i18n(S.IssueReportInstructions) + "\n" + e.stackTraceToString()   // TODO also display the thread name
    val alert = Alert(summary, message, AlertLevel.EXCEPTION, null, false, ERROR_DISPLAY_TIME)
    alerts.add(alert)
    alertChannel.trySend(alert)  // If nobody is listening, no need to show it
}
